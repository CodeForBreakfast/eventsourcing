{"id":"hp-1","title":"Check code using Effect-Language-Service CLI","description":"Use the Effect-Language-Service CLI to validate Effect code quality and setup.\n\nThe CLI provides Effect-specific diagnostics and validation:\n\n**Key Commands:**\n- `diagnostics`: Analyze Effect-specific issues (use --file for individual files or --project with tsconfig path)\n- `check`: Verify TypeScript patching status for compile-time diagnostics\n- `patch`: Enable Effect diagnostics at build time (add to npm prepare script to persist)\n\n**What it Validates:**\n- Floating Effects (unhandled Effect values)\n- Incorrect yield usage in Effect.gen\n- Multiple Effect versions in the project\n- Service dependency requirements\n\n**Usage:**\nShould be installed locally (not globally) to match project's TypeScript version.\n\n**Integration:**\nAdd to CI/CD pipeline or pre-commit hooks to catch Effect-specific issues early.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-25T13:28:50.391444+01:00","updated_at":"2025-10-25T14:28:41.592959+01:00","closed_at":"2025-10-25T14:28:41.592959+01:00"}
{"id":"hp-2","title":"Fix 25 Effect-specific errors in eslint-effect test files","description":"The eslint-effect package contains 37 test files with intentional Effect anti-patterns used to test ESLint rules. These test files create floating Effects (Effects that are created but never handled).\n\nExample issue: In test/no-runSync-runPromise.test.ts, Effect.runSync() and Effect.runPromise() create Effects but don't assign or handle them.\n\nThese need to be fixed by either:\n1. Running the Effects to completion\n2. Assigning them to exported variables\n3. Returning them from the test context\n\nThe test files are in packages/eslint-effect/test/*.test.ts\n\nThis was discovered during Effect-LS integration (hp-1) when TypeScript patching enabled compile-time Effect diagnostics.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-25T14:28:25.366918+01:00","updated_at":"2025-10-25T14:39:26.441293+01:00","closed_at":"2025-10-25T14:39:26.441293+01:00","dependencies":[{"issue_id":"hp-2","depends_on_id":"hp-1","type":"discovered-from","created_at":"2025-10-25T14:28:37.223575+01:00","created_by":"graemefoster"}]}
{"id":"hp-3","title":"Implement eventsourcing-server package with building block components","description":"Create @codeforbreakfast/eventsourcing-server package with four building block components that eliminate server boilerplate while maintaining flexibility.\n\nBased on learnings from origin/feat/websocket-example spike.\n\n**Components:**\n- EventBus: Server-side pub/sub for process managers\n- CommandDispatcher: Routes WireCommands to aggregates\n- StoreSubscriptionManager: Bridges EventStore to client subscriptions\n- ProtocolBridge: Wires ServerProtocol to CommandDispatcher\n\n**Package structure:**\n- packages/eventsourcing-server/\n- Uses Effect Context/Layer DI throughout\n- Low-level building blocks (not high-level wrappers)\n\n**Success criteria:**\n- All four components implemented with tests\n- Package published\n- Integration tests prove components work together\n\nSee: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-25T18:24:16.109284+01:00","updated_at":"2025-10-25T18:27:14.444845+01:00"}
{"id":"hp-4","title":"Implement EventBus component for server-side pub/sub","description":"Implement EventBus component for in-memory server-side event distribution.\n\n**Responsibility:**\nInternal pub/sub for process managers and projections. NOT for client event delivery.\n\n**Interface:**\n```typescript\nclass EventBus extends Context.Tag('EventBus')\u003cEventBus, {\n  publish: (event: DomainEvent) =\u003e Effect.Effect\u003cvoid\u003e\n  subscribe: (filter: (event: DomainEvent) =\u003e boolean) \n    =\u003e Effect.Effect\u003cStream.Stream\u003cDomainEvent\u003e\u003e\n}\u003e() {}\n\nconst EventBusLive: Layer.Layer\u003cEventBus\u003e\n```\n\n**Key points:**\n- NO historical replay - only current events\n- Fire-and-forget publishing (never fails)\n- Type-safe filtering for subscribers\n- Backed by Effect PubSub\n- Scoped lifecycle management\n\n**Tests:**\n- Publish event, subscriber receives it\n- Multiple subscribers get same event\n- Filtering works (subscriber only gets matching events)\n- Scope cleanup (no leaked subscriptions)\n- Integration: Real events from test aggregate\n\n**Files:**\n- src/lib/eventBus.ts\n- src/lib/eventBus.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:23.792152+01:00","updated_at":"2025-10-25T18:27:23.934056+01:00","dependencies":[{"issue_id":"hp-4","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:33.659656+01:00","created_by":"graemefoster"}]}
{"id":"hp-5","title":"Implement CommandDispatcher for routing WireCommands to aggregates","description":"Implement CommandDispatcher for routing WireCommands to aggregate command methods.\n\n**Responsibility:**\nConvention-based routing: WireCommand.name → aggregate.commands[methodName]\n\n**Interface:**\n```typescript\nclass CommandDispatcher extends Context.Tag('CommandDispatcher')\u003cCommandDispatcher, {\n  dispatch: (command: WireCommand) =\u003e Effect.Effect\u003cCommandResult, DispatchError\u003e\n}\u003e() {}\n\nconst CommandDispatcherLive: (config: {\n  aggregates: Array\u003cAggregateConfig\u003e\n}) =\u003e Layer.Layer\u003cCommandDispatcher, never, EventBus\u003e\n```\n\n**Key points:**\n- Maps CreateTodo → aggregate.commands.createTodo (camelCase)\n- Loads aggregate state from EventStore\n- Executes command, commits events\n- Publishes committed events to EventBus\n- Returns CommandResult (Success/Failure)\n- All errors become Failure (never crash)\n\n**Tests:**\n- Routes command to correct aggregate method\n- Loads aggregate state before execution\n- Commits events to EventStore\n- Publishes events to EventBus\n- Returns Success with position\n- Returns Failure for aggregate errors\n- Handles unknown command name\n- Integration: Real aggregate + store\n\n**Dependencies:**\n- EventBus (hp-4)\n- @codeforbreakfast/eventsourcing-aggregates\n- @codeforbreakfast/eventsourcing-commands\n\n**Files:**\n- src/lib/commandDispatcher.ts\n- src/lib/commandDispatcher.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.005514+01:00","updated_at":"2025-10-25T18:27:33.635576+01:00","dependencies":[{"issue_id":"hp-5","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:33.86119+01:00","created_by":"graemefoster"},{"issue_id":"hp-5","depends_on_id":"hp-4","type":"blocks","created_at":"2025-10-25T18:24:39.473376+01:00","created_by":"graemefoster"}]}
{"id":"hp-6","title":"Implement StoreSubscriptionManager for client event delivery","description":"Implement StoreSubscriptionManager to bridge EventStore subscriptions to client subscriptions.\n\n**Responsibility:**\nWatch client subscription state, dynamically subscribe to EventStore, pump events to clients.\n\n**Interface:**\n```typescript\nclass StoreSubscriptionManager extends Context.Tag('StoreSubscriptionManager')\u003c\n  StoreSubscriptionManager,\n  {\n    start: () =\u003e Effect.Effect\u003cnever, SubscriptionError\u003e\n  }\n\u003e() {}\n\nconst StoreSubscriptionManagerLive: (config: {\n  stores: Array\u003c{ \n    tag: EventStoreTag\n    streamPattern?: (streamId: string) =\u003e boolean \n  }\u003e\n}) =\u003e Layer.Layer\u003cStoreSubscriptionManager, never, ServerProtocol\u003e\n```\n\n**Key design insight:**\nWatches ServerProtocol's subscription HashMap (streamId → connectionIds). When clients subscribe, creates EventStore.subscribe(). When last client unsubscribes, cleans up store subscription.\n\n**Key points:**\n- Monitors ServerProtocol internal state (Ref\u003cServerState\u003e)\n- Creates EventStore subscriptions dynamically\n- Pumps events: EventStore → ServerProtocol.publishEvent()\n- Cleans up when no clients subscribed\n- Handles multiple EventStores (per aggregate type)\n- Does NOT filter/route (ServerProtocol does that)\n\n**Tests:**\n- Client subscribes → creates EventStore subscription\n- Events from store reach ServerProtocol.publishEvent\n- Last client unsubscribes → cleans up store subscription\n- Multiple clients subscribed → single store subscription\n- Handles multiple stores correctly\n- Integration: Real ServerProtocol + EventStore\n\n**Dependencies:**\n- @codeforbreakfast/eventsourcing-protocol (ServerProtocol)\n- @codeforbreakfast/eventsourcing-store (EventStore)\n\n**Challenges:**\n- Need to access ServerProtocol's internal Ref\u003cServerState\u003e\n- May require exposing subscription state or hooks in ServerProtocol\n\n**Files:**\n- src/lib/storeSubscriptionManager.ts\n- src/lib/storeSubscriptionManager.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.220875+01:00","updated_at":"2025-10-25T18:27:46.449482+01:00","dependencies":[{"issue_id":"hp-6","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:34.066468+01:00","created_by":"graemefoster"}]}
{"id":"hp-7","title":"Implement ProtocolBridge for wiring protocol to dispatcher","description":"Implement ProtocolBridge for wiring ServerProtocol command stream to CommandDispatcher.\n\n**Responsibility:**\nPure wiring function (NOT a service tag). Connects protocol commands to dispatcher, sends results back.\n\n**Interface:**\n```typescript\nconst makeProtocolBridge: (\n  protocol: Context.Tag.Service\u003ctypeof ServerProtocol\u003e\n) =\u003e Effect.Effect\u003cnever, BridgeError, CommandDispatcher | Scope.Scope\u003e\n```\n\n**Key points:**\n- Pure function, not a Context.Tag service\n- Wires protocol.onWireCommand → dispatcher.dispatch\n- Sends results back via protocol.sendResult\n- Does NOT handle events (StoreSubscriptionManager does that)\n- Returns Effect\u003cnever\u003e that runs forever\n- Lifecycle managed by Scope (interruption cleans up)\n\n**Implementation:**\n```typescript\nEffect.gen(function* () {\n  const dispatcher = yield* CommandDispatcher\n  \n  yield* pipe(\n    protocol.onWireCommand,\n    Stream.mapEffect((cmd) =\u003e \n      dispatcher.dispatch(cmd).pipe(\n        Effect.flatMap((result) =\u003e protocol.sendResult(cmd.id, result))\n      )\n    ),\n    Stream.runDrain\n  )\n})\n```\n\n**Tests:**\n- Commands from protocol reach dispatcher\n- Dispatcher results sent back through protocol\n- Command errors handled gracefully\n- One stream failure doesn't crash everything\n- Scope interruption cleans up properly\n- Integration: Full command → dispatcher → result flow\n\n**Dependencies:**\n- CommandDispatcher (hp-5)\n- @codeforbreakfast/eventsourcing-protocol\n\n**Files:**\n- src/lib/protocolBridge.ts\n- src/lib/protocolBridge.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.435636+01:00","updated_at":"2025-10-25T18:27:58.070051+01:00","dependencies":[{"issue_id":"hp-7","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:34.271078+01:00","created_by":"graemefoster"},{"issue_id":"hp-7","depends_on_id":"hp-5","type":"blocks","created_at":"2025-10-25T18:24:39.669899+01:00","created_by":"graemefoster"}]}
