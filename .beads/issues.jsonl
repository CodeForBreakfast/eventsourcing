{"id":"hp-1","content_hash":"0abb67dd2fb37e4bf0edc85c37cab145c7c512497e64857f6255ae373ec94de6","title":"Check code using Effect-Language-Service CLI","description":"Use the Effect-Language-Service CLI to validate Effect code quality and setup.\n\nThe CLI provides Effect-specific diagnostics and validation:\n\n**Key Commands:**\n- `diagnostics`: Analyze Effect-specific issues (use --file for individual files or --project with tsconfig path)\n- `check`: Verify TypeScript patching status for compile-time diagnostics\n- `patch`: Enable Effect diagnostics at build time (add to npm prepare script to persist)\n\n**What it Validates:**\n- Floating Effects (unhandled Effect values)\n- Incorrect yield usage in Effect.gen\n- Multiple Effect versions in the project\n- Service dependency requirements\n\n**Usage:**\nShould be installed locally (not globally) to match project's TypeScript version.\n\n**Integration:**\nAdd to CI/CD pipeline or pre-commit hooks to catch Effect-specific issues early.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-25T13:28:50.391444+01:00","updated_at":"2025-10-25T14:28:41.592959+01:00","closed_at":"2025-10-25T14:28:41.592959+01:00","source_repo":"."}
{"id":"hp-10","content_hash":"ef2b24ee75bca91e98301e3d4ccf59b6cc31d5b1e1a8d3957c0e8ad5f587dad7","title":"Refactor to introduce StoredEvent wherever there is a pair of EventStreamPosition and Event","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T10:20:55.133709Z","updated_at":"2025-10-26T13:59:27.623368Z","closed_at":"2025-10-26T13:59:27.623368Z","source_repo":".","dependencies":[{"issue_id":"hp-10","depends_on_id":"hp-9","type":"blocks","created_at":"2025-10-26T10:22:18.724252Z","created_by":"graemefoster"}]}
{"id":"hp-11","content_hash":"8a924e21e1cd811c7bbed0c7865ab77e3adc606beffe891dc77d74009833eb14","title":"Skip CI workflows for beads-only PRs","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T10:48:59.774837Z","updated_at":"2025-10-26T11:48:16.684935Z","closed_at":"2025-10-26T11:48:16.684935Z","source_repo":"."}
{"id":"hp-12","content_hash":"90e70d11ea1b1f2eb968597b0eb03649c95c294175cb604222d80b09858e6054","title":"Add EventBus test for late-arriving subscribers","description":"Add integration test for subscriber that joins an already-running EventBus after events have been published.\n\n**Scenario:**\n1. EventBus layer created\n2. Events written to EventStore (EventBus pump processes them)\n3. NEW subscriber joins via eventBus.subscribe()\n4. More events written\n5. Verify subscriber only receives events from step 4, not step 2\n\n**Difference from existing 'live-only' test:**\n- Existing test: events written BEFORE EventBus layer exists\n- New test: events written AFTER EventBus exists but BEFORE subscriber joins\n\n**Expected behavior:**\nSubscriber should only receive events published AFTER it subscribed, not events that were already processed by the EventBus pump before subscription.\n\n**Files:**\n- packages/eventsourcing-server/src/lib/eventBus.test.ts (add new test case)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T12:55:57.201872Z","updated_at":"2025-11-01T16:29:19.816089Z","closed_at":"2025-11-01T16:29:19.816089Z","source_repo":".","dependencies":[{"issue_id":"hp-12","depends_on_id":"hp-4","type":"discovered-from","created_at":"2025-10-27T12:55:57.203061Z","created_by":"graemefoster"}]}
{"id":"hp-13","content_hash":"59fe748797a2ac6881e2373679676929662d17c7667035256c8221baee43bfc8","title":"Add EventBus error handling tests","description":"Add tests for EventBus error scenarios:\n\n**Tests needed:**\n1. **EventStore.subscribeAll() failure:** If the store's subscribeAll() returns an error, the EventBus layer creation should fail gracefully\n2. **Pump fiber death:** If the pump fiber dies unexpectedly, subscribers should receive an error (not hang forever)\n3. **Filter exception:** If a subscriber's filter function throws, it should only affect that subscriber, not others\n\n**Expected behavior:**\n- Errors should be propagated to the correct scope (layer vs subscriber)\n- One subscriber's filter failure shouldn't kill the entire EventBus\n- Clear error messages for debugging\n\n**Files:**\n- packages/eventsourcing-server/src/lib/eventBus.test.ts (add error test cases)\n- packages/eventsourcing-server/src/lib/eventBus.ts (may need error handling improvements)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T14:58:14.537278Z","updated_at":"2025-11-02T10:10:14.632118Z","closed_at":"2025-11-02T10:10:14.632118Z","source_repo":".","dependencies":[{"issue_id":"hp-13","depends_on_id":"hp-4","type":"discovered-from","created_at":"2025-10-27T14:58:14.538111Z","created_by":"graemefoster"}]}
{"id":"hp-14","content_hash":"1237f8a91b5da1dad1840a45249c46a2913901e00fd91e0d04a016a704fa0915","title":"Add EventBus edge case tests","description":"Add tests for EventBus edge cases:\n\n**Tests needed:**\n1. **Empty stream:** EventBus runs but no events are ever published - subscriber should wait gracefully\n2. **Filter matches nothing:** Subscriber filter never matches - should receive empty stream (not error)\n3. **Unsubscribe before events:** Subscriber created but scope closed before any events arrive\n4. **Slow consumer:** One subscriber consumes slowly - shouldn't block other subscribers\n5. **Multiple EventBus instances:** Two EventBus layers on same EventStore - both should receive events independently\n\n**Expected behavior:**\n- Empty/no-match scenarios return empty streams, not errors\n- Slow consumers don't affect fast consumers (independent Dequeues)\n- Multiple EventBus instances work correctly (each has own pump)\n\n**Priority:** P3 (nice-to-have validation tests, not critical bugs)\n\n**Files:**\n- packages/eventsourcing-server/src/lib/eventBus.test.ts (add edge case tests)","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-27T14:58:32.986861Z","updated_at":"2025-10-27T14:58:43.620648Z","source_repo":".","dependencies":[{"issue_id":"hp-14","depends_on_id":"hp-4","type":"discovered-from","created_at":"2025-10-27T14:58:32.987652Z","created_by":"graemefoster"}]}
{"id":"hp-15","content_hash":"2715396bbc6ef75e7b19e787a0eb3f5573e717ab8078e897a973237171f0c2ae","title":"Refactor eventBus.test.ts to follow Effect eslint rules - remove disabled linting rules","description":"","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-10-27T17:26:54.735238Z","updated_at":"2025-10-27T17:43:31.404676Z","closed_at":"2025-10-27T17:43:31.404676Z","source_repo":".","dependencies":[{"issue_id":"hp-15","depends_on_id":"hp-16","type":"parent-child","created_at":"2025-10-27T17:28:48.844982Z","created_by":"graemefoster"}]}
{"id":"hp-16","content_hash":"4d06a2111ca121c18f2958ab5458bb8efe4e6391233bbe82d2693a6e08e84e96","title":"Codebase-wide refactor: Remove all disabled Effect eslint rules from test files (23 violations across 9 files)","description":"","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-10-27T17:28:43.348154Z","updated_at":"2025-10-28T06:57:23.922603Z","closed_at":"2025-10-28T06:57:23.922603Z","source_repo":"."}
{"id":"hp-17","content_hash":"b62d2307fbd005a1d8550246ad8bf3e3f3bc890eb6c41cae30f7904fedc12e04","title":"Replace isCommandSuccess/isCommandFailure type guards with Match.tag throughout codebase","description":"The codebase currently uses type guard functions isCommandSuccess and isCommandFailure to check discriminated union tags on CommandResult. This is an imperative pattern that doesn't leverage Effect's functional matching capabilities.\n\n## Why This Matters\n\n1. Consistency with Effect patterns: Effect provides Match.tag specifically for discriminated unions with _tag fields. Using it makes the code more idiomatic.\n\n2. Better type inference: Match.tag provides better type narrowing within match branches and ensures exhaustive handling.\n\n3. Reduces imperative style: Type guard functions with if statements are imperative. Match.tag with Match.orElse is functional composition.\n\n4. Avoids side effects: The current pattern often leads to imperative control flow. With Match, we get functional composition.\n\n5. Already started: We've refactored verifySuccessResult and verifyFailureResult to use Match.tag. The rest of protocol.test.ts and potentially other files still use the old pattern.\n\n## Scope\n\nSearch for all uses of isCommandSuccess and isCommandFailure in:\n- packages/eventsourcing-protocol/src/lib/protocol.test.ts (many remaining uses around lines 115, 395, 606, 705, 845, 846, 1412, 1597-1600, 1736-1741, 1791-1794, 2077-2081, 2264)\n- Any other files in the codebase that import these functions\n\nReplace with Match.tag('Success', ...) and Match.tag('Failure', ...) patterns.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T07:16:02.699967Z","updated_at":"2025-10-28T07:16:02.699967Z","source_repo":"."}
{"id":"hp-18","content_hash":"e27a594fbe55f7988cd34697b9a9c6ea9ab7679980d852434183237f9cf4f450","title":"Replace JSON.parse with Schema validation in test error message parsing","description":"The test helper functions currently use JSON.parse with type assertions when parsing error messages. This is unsafe and doesn't provide proper validation. We should use Schema.decodeUnknown instead.\n\n## Current problem\n\nIn parseErrorMessage (line 337-344), we have:\n```typescript\nJSON.parse(message) as {\n  readonly _tag: string;\n  readonly validationErrors?: readonly string[];\n}\n```\n\nThis bypasses all type safety and validation. If the JSON structure doesn't match, we won't know until runtime failures occur.\n\n## Solution\n\nReplace JSON.parse with Schema validation:\n\n1. Define a Schema for the parsed error structure (or reuse existing schemas if available)\n2. Use Schema.decodeUnknown to parse and validate the JSON string\n3. This gives us proper error messages when parsing fails\n\nExample:\n```typescript\nconst ParsedErrorSchema = Schema.Struct({\n  _tag: Schema.String,\n  validationErrors: Schema.optional(Schema.Array(Schema.String))\n});\n\npipe(\n  message,\n  Schema.decodeUnknown(ParsedErrorSchema),\n  Effect.mapError((error) =\u003e new Error(`Failed to parse error message: ${error}`))\n)\n```\n\n## Benefits\n\n- Type-safe parsing with validation\n- Better error messages when parsing fails  \n- Removes unsafe type assertions\n- More idiomatic Effect code\n\n## Location\n\npackages/eventsourcing-protocol/src/lib/protocol.test.ts:337-344 in the parseErrorMessage function","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T07:18:09.856216Z","updated_at":"2025-10-28T07:19:46.542619Z","source_repo":"."}
{"id":"hp-19","content_hash":"b62f15988fe6d93c06c07a383bd87358db92c11ba831180de749faca180de580","title":"Add EventBus test for historical events before layer creation","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-01T16:23:29.710897Z","updated_at":"2025-11-01T17:14:44.038165Z","closed_at":"2025-11-01T17:14:44.038165Z","source_repo":".","dependencies":[{"issue_id":"hp-19","depends_on_id":"hp-12","type":"discovered-from","created_at":"2025-11-01T16:23:29.711727Z","created_by":"graemefoster"}]}
{"id":"hp-2","content_hash":"a351bb2ac4113d4d036db96e0b3a3a321d7fe4986f41d6c3bf74719d95dc8b83","title":"Fix 25 Effect-specific errors in eslint-effect test files","description":"The eslint-effect package contains 37 test files with intentional Effect anti-patterns used to test ESLint rules. These test files create floating Effects (Effects that are created but never handled).\n\nExample issue: In test/no-runSync-runPromise.test.ts, Effect.runSync() and Effect.runPromise() create Effects but don't assign or handle them.\n\nThese need to be fixed by either:\n1. Running the Effects to completion\n2. Assigning them to exported variables\n3. Returning them from the test context\n\nThe test files are in packages/eslint-effect/test/*.test.ts\n\nThis was discovered during Effect-LS integration (hp-1) when TypeScript patching enabled compile-time Effect diagnostics.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-25T14:28:25.366918+01:00","updated_at":"2025-10-25T14:39:26.441293+01:00","closed_at":"2025-10-25T14:39:26.441293+01:00","source_repo":".","dependencies":[{"issue_id":"hp-2","depends_on_id":"hp-1","type":"discovered-from","created_at":"2025-10-25T14:28:37.223575+01:00","created_by":"graemefoster"}]}
{"id":"hp-22","content_hash":"1164a3bdc0362509fffaed9ee1d78627ad2d1f49d9dd0a4e26d64428985d844c","title":"Implement EventBus filter exception test and error handling","description":"Complete the third error handling test case for EventBus that was deferred during hp-13.\n\n**Requirement:**\nWhen a subscriber's filter function throws an exception, it should only affect that subscriber, not crash the entire EventBus or impact other subscribers.\n\n**Current State:**\n- TODO comment added in eventBus.test.ts lines 458-462\n- No error handling exists in filterEvent() function (eventBus.ts lines 73-82)\n- Currently, any exception in a filter will crash the stream\n\n**Implementation needed:**\n\n1. **Add error handling to eventBus.ts:**\n   - Location: filterEvent() function at lines 73-82\n   - Current code uses a simple ternary with filter(streamEvent.event)\n   - Wrap the filter call in try/catch or use Effect-based error handling\n   - Return Option.none() if filter throws (silently skip the event for that subscriber)\n\n2. **Write test in eventBus.test.ts:**\n   - Location: After line 462 (where TODO comment is)\n   - Pattern to follow: Look at 'subscribers complete gracefully when pump fiber dies' test (lines 464-492)\n   - That test successfully satisfies the linter - use its structure\n   - Test structure:\n     a. Create two subscribers (one with throwing filter, one normal)\n     b. Publish 2 events via makeTestStoreLayer\n     c. Verify normal subscriber gets 2 events\n     d. Verify throwing subscriber handles error gracefully\n\n**Reference implementations:**\n- Lines 433-456: Shows how to test layer creation failure\n- Lines 464-492: Shows how to test pump failure with Effect.either\n- Both pass linter - use them as templates\n\n**Linter requirements:**\n- No nested pipe() calls - extract to named functions\n- No curried calls - use full parameter lists\n- Use Effect.either to catch errors without Effect.sync\n- Use Chunk operations for result verification\n\n**Testing approach:**\nRun: turbo test --filter='@codeforbreakfast/eventsourcing-server'\nAll 8 existing tests must continue to pass.\n\n**Files:**\n- packages/eventsourcing-server/src/lib/eventBus.ts (add error handling)\n- packages/eventsourcing-server/src/lib/eventBus.test.ts (implement test)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-02T10:11:43.462333Z","updated_at":"2025-11-02T10:36:36.191137Z","closed_at":"2025-11-02T10:36:36.191137Z","source_repo":".","dependencies":[{"issue_id":"hp-22","depends_on_id":"hp-13","type":"discovered-from","created_at":"2025-11-02T10:11:43.463456Z","created_by":"graemefoster"}]}
{"id":"hp-23","content_hash":"befee8170864336b3ca87de1be7a62a72d89a4a404f2e76b33b91f46ddd81c99","title":"Refactor filterEvent to avoid eslint-disable and improve code quality","description":"The filterEvent function in eventBus.ts currently uses an eslint-disable comment to bypass the effect/prefer-match-over-ternary rule. We should refactor this to use proper Effect patterns.\n\n**Current code (eventBus.ts:73-88):**\n```typescript\nconst filterEvent =\n  \u003cTFiltered extends TEvent\u003e(filter: (event: TEvent) =\u003e event is TFiltered) =\u003e\n  (streamEvent: StreamEvent\u003cTEvent\u003e): Option.Option\u003cStreamEvent\u003cTFiltered\u003e\u003e =\u003e {\n    try {\n      // eslint-disable-next-line effect/prefer-match-over-ternary -- Simple boolean check for type guard, Match pattern would be unnecessarily verbose\n      return filter(streamEvent.event)\n        ? Option.some({\n            position: streamEvent.position,\n            event: streamEvent.event as TFiltered,\n          })\n        : Option.none();\n    } catch {\n      // Filter threw an exception - return none to skip this event for this subscriber\n      return Option.none();\n    }\n  };\n```\n\n**Issues:**\n1. Uses eslint-disable to bypass effect/prefer-match-over-ternary\n2. Uses try/catch instead of Effect-based error handling\n3. The justification claims Match would be verbose, but we should verify this\n\n**Goals:**\n1. Remove the eslint-disable comment\n2. Consider using Effect-based error handling (Effect.try or similar)\n3. Evaluate if Match.value is actually more verbose or if it improves code quality\n4. Maintain the same behavior (filter exceptions should silently skip events)\n\n**Files:**\n- packages/eventsourcing-server/src/lib/eventBus.ts\n\n**Testing:**\nAll existing tests should continue to pass, especially the filter exception test.","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-11-02T11:23:10.934067Z","updated_at":"2025-11-02T12:24:22.561989Z","closed_at":"2025-11-02T12:24:22.561989Z","source_repo":"."}
{"id":"hp-3","content_hash":"d49b206743a78a2ad5d9245b478aeeaf449672cd06463a5ae7c40ed03934690e","title":"Implement eventsourcing-server package with building block components","description":"Create @codeforbreakfast/eventsourcing-server package with four building block components that eliminate server boilerplate while maintaining flexibility.\n\nBased on learnings from origin/feat/websocket-example spike.\n\n**Components:**\n- EventBus: Server-side pub/sub for process managers\n- CommandDispatcher: Routes WireCommands to aggregates\n- StoreSubscriptionManager: Bridges EventStore to client subscriptions\n- ProtocolBridge: Wires ServerProtocol to CommandDispatcher\n\n**Package structure:**\n- packages/eventsourcing-server/\n- Uses Effect Context/Layer DI throughout\n- Low-level building blocks (not high-level wrappers)\n\n**Success criteria:**\n- All four components implemented with tests\n- Package published\n- Integration tests prove components work together\n\nSee: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-25T18:24:16.109284+01:00","updated_at":"2025-10-25T18:27:14.444845+01:00","source_repo":"."}
{"id":"hp-4","content_hash":"fb87c627b8265d03e534c05a33baf5002b26e9b338f60a70aa1c9af9fdeee1fe","title":"Implement EventBus component for server-side pub/sub","description":"Implement EventBus component for live server-side event distribution via EventStore.subscribeAll().\n\n**Responsibility:**\nSubscribe to EventStore.subscribeAll() and distribute events to process managers and projections.\n\n**Interface:**\n```typescript\nclass EventBus extends Context.Tag('EventBus')\u003cEventBus, {\n  subscribe: (filter: (event: DomainEvent) =\u003e boolean) \n    =\u003e Effect.Effect\u003cStream.Stream\u003cDomainEvent\u003e\u003e\n}\u003e() {}\n\nconst EventBusLive: (config: {\n  store: EventStoreTag\n}) =\u003e Layer.Layer\u003cEventBus, never, EventStore\u003e\n```\n\n**Key points:**\n- Uses EventStore.subscribeAll() internally to get all events\n- Live-only (no historical replay)\n- Best-effort delivery (not guaranteed)\n- Works across multiple server instances (via EventStore subscription)\n- Type-safe filtering for subscribers\n- Does NOT receive events from CommandDispatcher\n- Scoped lifecycle management\n\n**Implementation approach:**\n1. On layer creation, call store.subscribeAll()\n2. Maintain internal PubSub for subscribers\n3. Pump events: EventStore.subscribeAll() → internal PubSub\n4. Subscribers get filtered stream from PubSub\n\n**Tests:**\n- Subscribe to EventStore.subscribeAll() on startup\n- Events committed to ANY stream appear on EventBus\n- Type-safe filtering works correctly\n- Multiple subscribers receive same event\n- Live-only: events committed before subscription start do NOT appear\n- Multi-instance: events from different server instance appear\n- Scope cleanup (no leaked subscriptions)\n- Integration: Real EventStore with subscribeAll support\n\n**Dependencies:**\n- Blocked by hp-8 (EventStore.subscribeAll() implementation)\n- @codeforbreakfast/eventsourcing-store (EventStore)\n\n**Files:**\n- src/lib/eventBus.ts\n- src/lib/eventBus.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:23.792152+01:00","updated_at":"2025-10-27T12:33:14.371476Z","closed_at":"2025-10-27T12:33:14.371476Z","source_repo":".","dependencies":[{"issue_id":"hp-4","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:33.659656+01:00","created_by":"graemefoster"}]}
{"id":"hp-5","content_hash":"f1db7294711264052eb55a6699fd12bb5652046f7a3fcafcf25cef09dd58688d","title":"Implement CommandDispatcher for routing WireCommands to aggregates","description":"Implement CommandDispatcher for routing WireCommands to aggregate command methods.\n\n**Responsibility:**\nConvention-based routing: WireCommand.name → aggregate.commands[methodName]\n\n**Interface:**\n```typescript\nclass CommandDispatcher extends Context.Tag('CommandDispatcher')\u003cCommandDispatcher, {\n  dispatch: (command: WireCommand) =\u003e Effect.Effect\u003cCommandResult, DispatchError\u003e\n}\u003e() {}\n\nconst CommandDispatcherLive: (config: {\n  aggregates: Array\u003cAggregateConfig\u003e\n}) =\u003e Layer.Layer\u003cCommandDispatcher, never, never\u003e\n```\n\n**Key points:**\n- Maps CreateTodo → aggregate.commands.createTodo (camelCase)\n- Loads aggregate state from EventStore\n- Executes command, commits events to EventStore\n- Returns CommandResult (Success/Failure)\n- Does NOT publish to EventBus (EventBus gets events via subscribeAll)\n- All errors become Failure (never crash)\n\n**Tests:**\n- Routes command to correct aggregate method\n- Loads aggregate state before execution\n- Commits events to EventStore\n- Returns Success with position\n- Returns Failure for aggregate errors\n- Handles unknown command name\n- Does NOT publish to EventBus directly\n- Integration: Real aggregate + store\n\n**Dependencies:**\n- Blocked by hp-8 (EventStore.subscribeAll() must exist first)\n- @codeforbreakfast/eventsourcing-aggregates\n- @codeforbreakfast/eventsourcing-commands\n- @codeforbreakfast/eventsourcing-store\n\n**Note:** CommandDispatcher no longer depends on EventBus. It just commits to EventStore, and EventBus receives events via subscribeAll().\n\n**Files:**\n- src/lib/commandDispatcher.ts\n- src/lib/commandDispatcher.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.005514+01:00","updated_at":"2025-10-25T18:44:43.514468+01:00","source_repo":".","dependencies":[{"issue_id":"hp-5","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:33.86119+01:00","created_by":"graemefoster"},{"issue_id":"hp-5","depends_on_id":"hp-8","type":"blocks","created_at":"2025-10-25T18:44:50.408009+01:00","created_by":"graemefoster"}]}
{"id":"hp-6","content_hash":"de702b6c69e437fd9114ccfeb9a2e840ea3d0d55ff067a875b237a5770199afa","title":"Implement StoreSubscriptionManager for client event delivery","description":"Implement StoreSubscriptionManager to bridge EventStore subscriptions to client subscriptions.\n\n**Responsibility:**\nWatch client subscription state, dynamically subscribe to EventStore, pump events to clients.\n\n**Interface:**\n```typescript\nclass StoreSubscriptionManager extends Context.Tag('StoreSubscriptionManager')\u003c\n  StoreSubscriptionManager,\n  {\n    start: () =\u003e Effect.Effect\u003cnever, SubscriptionError\u003e\n  }\n\u003e() {}\n\nconst StoreSubscriptionManagerLive: (config: {\n  stores: Array\u003c{ \n    tag: EventStoreTag\n    streamPattern?: (streamId: string) =\u003e boolean \n  }\u003e\n}) =\u003e Layer.Layer\u003cStoreSubscriptionManager, never, ServerProtocol\u003e\n```\n\n**Key design insight:**\nWatches ServerProtocol's subscription HashMap (streamId → connectionIds). When clients subscribe, creates EventStore.subscribe(). When last client unsubscribes, cleans up store subscription.\n\n**Key points:**\n- Monitors ServerProtocol internal state (Ref\u003cServerState\u003e)\n- Creates EventStore subscriptions dynamically\n- Pumps events: EventStore → ServerProtocol.publishEvent()\n- Cleans up when no clients subscribed\n- Handles multiple EventStores (per aggregate type)\n- Does NOT filter/route (ServerProtocol does that)\n\n**Tests:**\n- Client subscribes → creates EventStore subscription\n- Events from store reach ServerProtocol.publishEvent\n- Last client unsubscribes → cleans up store subscription\n- Multiple clients subscribed → single store subscription\n- Handles multiple stores correctly\n- Integration: Real ServerProtocol + EventStore\n\n**Dependencies:**\n- @codeforbreakfast/eventsourcing-protocol (ServerProtocol)\n- @codeforbreakfast/eventsourcing-store (EventStore)\n\n**Challenges:**\n- Need to access ServerProtocol's internal Ref\u003cServerState\u003e\n- May require exposing subscription state or hooks in ServerProtocol\n\n**Files:**\n- src/lib/storeSubscriptionManager.ts\n- src/lib/storeSubscriptionManager.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.220875+01:00","updated_at":"2025-10-25T18:27:46.449482+01:00","source_repo":".","dependencies":[{"issue_id":"hp-6","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:34.066468+01:00","created_by":"graemefoster"}]}
{"id":"hp-7","content_hash":"e32cfa437167242ca3d43601900ae31674a7401f889527ef039adc27a93cdd89","title":"Implement ProtocolBridge for wiring protocol to dispatcher","description":"Implement ProtocolBridge for wiring ServerProtocol command stream to CommandDispatcher.\n\n**Responsibility:**\nPure wiring function (NOT a service tag). Connects protocol commands to dispatcher, sends results back.\n\n**Interface:**\n```typescript\nconst makeProtocolBridge: (\n  protocol: Context.Tag.Service\u003ctypeof ServerProtocol\u003e\n) =\u003e Effect.Effect\u003cnever, BridgeError, CommandDispatcher | Scope.Scope\u003e\n```\n\n**Key points:**\n- Pure function, not a Context.Tag service\n- Wires protocol.onWireCommand → dispatcher.dispatch\n- Sends results back via protocol.sendResult\n- Does NOT handle events (StoreSubscriptionManager does that)\n- Returns Effect\u003cnever\u003e that runs forever\n- Lifecycle managed by Scope (interruption cleans up)\n\n**Implementation:**\n```typescript\nEffect.gen(function* () {\n  const dispatcher = yield* CommandDispatcher\n  \n  yield* pipe(\n    protocol.onWireCommand,\n    Stream.mapEffect((cmd) =\u003e \n      dispatcher.dispatch(cmd).pipe(\n        Effect.flatMap((result) =\u003e protocol.sendResult(cmd.id, result))\n      )\n    ),\n    Stream.runDrain\n  )\n})\n```\n\n**Tests:**\n- Commands from protocol reach dispatcher\n- Dispatcher results sent back through protocol\n- Command errors handled gracefully\n- One stream failure doesn't crash everything\n- Scope interruption cleans up properly\n- Integration: Full command → dispatcher → result flow\n\n**Dependencies:**\n- CommandDispatcher (hp-5)\n- @codeforbreakfast/eventsourcing-protocol\n\n**Files:**\n- src/lib/protocolBridge.ts\n- src/lib/protocolBridge.test.ts\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-25T18:24:24.435636+01:00","updated_at":"2025-10-25T18:27:58.070051+01:00","source_repo":".","dependencies":[{"issue_id":"hp-7","depends_on_id":"hp-3","type":"parent-child","created_at":"2025-10-25T18:24:34.271078+01:00","created_by":"graemefoster"},{"issue_id":"hp-7","depends_on_id":"hp-5","type":"blocks","created_at":"2025-10-25T18:24:39.669899+01:00","created_by":"graemefoster"}]}
{"id":"hp-8","content_hash":"60a193979a80222dbd620b709cf6bd516a0d4d3d2873f1e0efd868f17542280e","title":"Add subscribeAll() to EventStore for live cross-stream subscriptions","description":"Add required subscribeAll() method to EventStore interface for live, cross-stream event subscriptions.\n\n**Purpose:**\nEnable EventBus and process managers to receive events from all streams without per-stream subscriptions.\n\n**Design Decisions:**\n- REQUIRED for all EventStore implementations\n- Live-only (no historical replay, no global event number)\n- Best-effort delivery (not guaranteed)\n- Stream-independent (no global ordering required)\n\n**Interface (types TBD during implementation):**\n```typescript\ninterface EventStore\u003cTEvent\u003e {\n  // Existing per-stream subscription\n  readonly subscribe: (from: EventStreamPosition) \n    =\u003e Effect.Effect\u003cStream.Stream\u003cTEvent, ...\u003e, ...\u003e\n  \n  // NEW: All streams, live-only (REQUIRED)\n  readonly subscribeAll: () \n    =\u003e Effect.Effect\u003c\n         ??? // Stream.Stream or PubSub or something else?\n         // Must include: {streamId: string, event: TEvent}\n       \u003e\n}\n```\n\n**Implementation Notes:**\n\n**Postgres:**\n- Use existing LISTEN/NOTIFY infrastructure\n- Already triggers on all events (migration 0002)\n- Trivial to implement\n\n**InMemory:**\n- Already has events in memory\n- Simple PubSub broadcast\n\n**Filesystem:**\n- File watcher on base directory\n- Or polling-based\n- More complex but feasible\n\n**Key Questions to Investigate:**\n1. Should this return Stream.Stream, PubSub, or something else?\n2. What Error and Requirement types?\n3. Does it need Scope.Scope for cleanup?\n4. Should stores publish to a provided PubSub instead of returning one?\n\n**Out of Scope:**\n- Historical replay (use per-stream subscribe for that)\n- Global event ordering\n- Guaranteed delivery (use external queues)\n- Event filtering (EventBus does that)\n\n**Use Cases:**\n- EventBus subscribes to get all events for process managers\n- Process managers filter by event type\n- Projections that need cross-stream views\n\n**If process managers need guarantees:**\n- Don't use EventBus/subscribeAll\n- Publish to external queue (SQS, RabbitMQ, etc.) from CommandDispatcher\n- That's out of scope for this package\n\n**Testing:**\n- All three stores implement it\n- Events from any stream appear in subscription\n- Events committed after subscription start appear\n- Historical events do NOT appear (live-only)\n- Scope cleanup works correctly\n- Contract tests in eventsourcing-testing-contracts\n\n**Dependencies:**\nThis blocks EventBus (hp-4) implementation\n\n**Files:**\n- packages/eventsourcing-store/src/lib/services.ts (interface)\n- packages/eventsourcing-store-postgres/src/sqlEventStore.ts\n- packages/eventsourcing-store-inmemory/src/lib/inMemoryEventStore.ts\n- packages/eventsourcing-store-filesystem/src/lib/fileSystemEventStore.ts\n- packages/eventsourcing-testing-contracts/src/lib/store/subscribeAll.contract.ts (new)\n\nSee design: docs/plans/2025-10-25-eventsourcing-server-components-design.md","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T18:42:07.190593+01:00","updated_at":"2025-10-26T12:14:29.688302Z","closed_at":"2025-10-26T12:14:29.688302Z","source_repo":"."}
{"id":"hp-9","content_hash":"3484b19899a63707a4b1fd0f9429c0dea19622ca57ec27b68915f7f48aef26fa","title":"Refactor to introduce EventStreamPosition wherever there is a pair of stream id and event number","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T10:20:15.171677Z","updated_at":"2025-10-26T12:25:06.822815Z","closed_at":"2025-10-26T12:25:06.822815Z","source_repo":"."}
